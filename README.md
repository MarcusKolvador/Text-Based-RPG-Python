# Through The Flames: Prologue
#### Video Demo:
https://www.youtube.com/watch?v=p9sKE99moQs
#### Description:
My project, being a final project for the CS50 Python course, is a small, text-based RPG game called "Through The Flames: Prologue". It is a creative work, tying together and drawing inspiration from some concepts stemming from OC's of mine and a close friend's we created in close collaboration with each other, in out own, fantasy setting years ago. The use of these concepts, in the Prologue version, portrayed here however, is only of a basic, fundamental level.

As for the game itself - in summary, it is a fairly linear RPG with some choice elements, set on a 4x4 grid map. It contains dialogue, a rudimentary stat, class and status-effect system and some puzzles/discoverable items that effect the success of the ending of the game. Furthermore, the game contains a basic combat system, handled by functions and the class system for the player and enemy entity. I created these systems with the potential plans of further expanding, or if need be rewriting them in an expanded-scope project one day, depending on how I look back at it with further knowledge, skill and experience I pick up along the way. Diving into the nitty-gritty however...

The project is written in a single file, called project.py. Along with it, paired comes the test_project.py which tests some functions, that take in direct inputs and return direct outputs.

The file can be run with a -d CLI argument, which effectively bypasses the 'writer' function, further elaborated on in the next paragraph, making it work like a print function. The intro section of the game takes three inputs, explained within the game dialogue itself - enter, quit or help, respectively starting the adventure, opening the help menu or exiting the program.
The help and quit inputs remain functional through the rest of the program.

One of the most notable design choices for me, was the inclusion of a 'writer' function, which in most (and especially the dialogue) elements, replaces the print function.
The choice of write/print options and pauses is almost always (and I sincerely hope always evidently) premeditated, though I realize this, and pause lengths are a fine art and skill, that requires fine-tuning. As they say, Rome wasn't built in a day.
That aside, the writer function prints out each letter of the string one by one, using the sys.stdout.write() function method, followed by the .flush() method, meaning each character of the string is written into the stdout buffer, and immediately displayed, followed by a time.sleep(0.03), resulting in a game-like dialogue display, reminiscent of titles like Pokemon. For ease of testing, the time.sleep(0.03) value is placed within a conditional, with an option for a zero time if the program is run with a -d argument. This choice made running through the game and test-playing far more convenient and less time-consuming.

Upon entering the game world, we are presented with a dialogue, with introductory dialogue, world-building and a class choice dialogue, which attributes an archetype and appropriate stats to the Player function. The archetype is referenced in dialogue at appropriate moments, and dictates, what weapon the character obtains in one of the puzzles. This lays basic groundwork for further expansions of systems and work on this helped me understand how to tackle similar problems in the future.

Talking of puzzles, scattered along the map, there is one riddle, one combination lock, whose combination is hinted at in two locations and one discoverable item, which grants an extra action, where the answer to the riddle becomes necessary for unveiling one of the symbols for the combination lock.
Effectively, a completion of these problems is necessary to complete the game with the good ending. Failing to do so, and attempting to tackle the enemy (who is hinted at being extremely dangerous) results in a bad ending to the story.

The map itself is written out in a nested dictionary. While extremely large, this implementation allows for manual setting of each zone's name, description and examination function return (the examination function allows for interactivity with the zone, either triggering a combat scenario, extra dialogue, extra flavor text, a secondary function, status effect and the like). Each 'zone' is linked to another with the directions up, down, left, right, which through movement functions call on this attribute and move the player to the appropriate zone. For border zones of the map, I simply left the movement direction outside of the map as an empty string, and added a conditional statement, returning a flavor text of inability to move there if the string is empty. I imagined tackling the borders of the map to be extremely daunting for some reason, but having come upon this idea, I was greatly relieved.

The combat itself, while functional, is heavily scripted. There are three rounds of the turn-based combat, with an option to attack, guard or singularly use the aid of the ally companion. Appropriate text, static damage and resource costs are added for each of the attacks, both for the dragon and player. There is no randomness in the dragon's attacks and due to the stat attribution, failure is impossible, however, designing these systems laid out my understanding of how to actually implement such systems. Guarding itself was a fun thing to implement, since it applies a 'guarded' status effect, which lasts only one turn, but bypasses all damage and changes the dialogue displayed.

Overall, this project was immensely productive for me, while time consuming, it tackled my brain in a completely different way than the set problems, called on my creative imagination and turned out to be extremely fun, while daunting at times.
I also found myself tying together quite a lot of loose ends in my understanding of python, and solidified my ability, and confidence to further pursue the programming path.
